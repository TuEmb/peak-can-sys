/* automatically generated by rust-bindgen 0.59.1 */

pub const PEAK_NONEBUS: u32 = 0;
pub const PEAK_ISABUS1: u32 = 33;
pub const PEAK_ISABUS2: u32 = 34;
pub const PEAK_ISABUS3: u32 = 35;
pub const PEAK_ISABUS4: u32 = 36;
pub const PEAK_ISABUS5: u32 = 37;
pub const PEAK_ISABUS6: u32 = 38;
pub const PEAK_ISABUS7: u32 = 39;
pub const PEAK_ISABUS8: u32 = 40;
pub const PEAK_DNGBUS1: u32 = 49;
pub const PEAK_PCIBUS1: u32 = 65;
pub const PEAK_PCIBUS2: u32 = 66;
pub const PEAK_PCIBUS3: u32 = 67;
pub const PEAK_PCIBUS4: u32 = 68;
pub const PEAK_PCIBUS5: u32 = 69;
pub const PEAK_PCIBUS6: u32 = 70;
pub const PEAK_PCIBUS7: u32 = 71;
pub const PEAK_PCIBUS8: u32 = 72;
pub const PEAK_PCIBUS9: u32 = 1033;
pub const PEAK_PCIBUS10: u32 = 1034;
pub const PEAK_PCIBUS11: u32 = 1035;
pub const PEAK_PCIBUS12: u32 = 1036;
pub const PEAK_PCIBUS13: u32 = 1037;
pub const PEAK_PCIBUS14: u32 = 1038;
pub const PEAK_PCIBUS15: u32 = 1039;
pub const PEAK_PCIBUS16: u32 = 1040;
pub const PEAK_USBBUS1: u32 = 81;
pub const PEAK_USBBUS2: u32 = 82;
pub const PEAK_USBBUS3: u32 = 83;
pub const PEAK_USBBUS4: u32 = 84;
pub const PEAK_USBBUS5: u32 = 85;
pub const PEAK_USBBUS6: u32 = 86;
pub const PEAK_USBBUS7: u32 = 87;
pub const PEAK_USBBUS8: u32 = 88;
pub const PEAK_USBBUS9: u32 = 1289;
pub const PEAK_USBBUS10: u32 = 1290;
pub const PEAK_USBBUS11: u32 = 1291;
pub const PEAK_USBBUS12: u32 = 1292;
pub const PEAK_USBBUS13: u32 = 1293;
pub const PEAK_USBBUS14: u32 = 1294;
pub const PEAK_USBBUS15: u32 = 1295;
pub const PEAK_USBBUS16: u32 = 1296;
pub const PEAK_PCCBUS1: u32 = 97;
pub const PEAK_PCCBUS2: u32 = 98;
pub const PEAK_LANBUS1: u32 = 2049;
pub const PEAK_LANBUS2: u32 = 2050;
pub const PEAK_LANBUS3: u32 = 2051;
pub const PEAK_LANBUS4: u32 = 2052;
pub const PEAK_LANBUS5: u32 = 2053;
pub const PEAK_LANBUS6: u32 = 2054;
pub const PEAK_LANBUS7: u32 = 2055;
pub const PEAK_LANBUS8: u32 = 2056;
pub const PEAK_LANBUS9: u32 = 2057;
pub const PEAK_LANBUS10: u32 = 2058;
pub const PEAK_LANBUS11: u32 = 2059;
pub const PEAK_LANBUS12: u32 = 2060;
pub const PEAK_LANBUS13: u32 = 2061;
pub const PEAK_LANBUS14: u32 = 2062;
pub const PEAK_LANBUS15: u32 = 2063;
pub const PEAK_LANBUS16: u32 = 2064;
pub const PEAK_ERROR_OK: u32 = 0;
pub const PEAK_ERROR_XMTFULL: u32 = 1;
pub const PEAK_ERROR_OVERRUN: u32 = 2;
pub const PEAK_ERROR_BUSLIGHT: u32 = 4;
pub const PEAK_ERROR_BUSHEAVY: u32 = 8;
pub const PEAK_ERROR_BUSWARNING: u32 = 8;
pub const PEAK_ERROR_BUSPASSIVE: u32 = 262144;
pub const PEAK_ERROR_BUSOFF: u32 = 16;
pub const PEAK_ERROR_ANYBUSERR: u32 = 262172;
pub const PEAK_ERROR_QRCVEMPTY: u32 = 32;
pub const PEAK_ERROR_QOVERRUN: u32 = 64;
pub const PEAK_ERROR_QXMTFULL: u32 = 128;
pub const PEAK_ERROR_REGTEST: u32 = 256;
pub const PEAK_ERROR_NODRIVER: u32 = 512;
pub const PEAK_ERROR_HWINUSE: u32 = 1024;
pub const PEAK_ERROR_NETINUSE: u32 = 2048;
pub const PEAK_ERROR_ILLHW: u32 = 5120;
pub const PEAK_ERROR_ILLNET: u32 = 6144;
pub const PEAK_ERROR_ILLCLIENT: u32 = 7168;
pub const PEAK_ERROR_ILLHANDLE: u32 = 7168;
pub const PEAK_ERROR_RESOURCE: u32 = 8192;
pub const PEAK_ERROR_ILLPARAMTYPE: u32 = 16384;
pub const PEAK_ERROR_ILLPARAMVAL: u32 = 32768;
pub const PEAK_ERROR_UNKNOWN: u32 = 65536;
pub const PEAK_ERROR_ILLDATA: u32 = 131072;
pub const PEAK_ERROR_ILLMODE: u32 = 524288;
pub const PEAK_ERROR_CAUTION: u32 = 33554432;
pub const PEAK_ERROR_INITIALIZE: u32 = 67108864;
pub const PEAK_ERROR_ILLOPERATION: u32 = 134217728;
pub const PEAK_NONE: u32 = 0;
pub const PEAK_PEAKCAN: u32 = 1;
pub const PEAK_ISA: u32 = 2;
pub const PEAK_DNG: u32 = 3;
pub const PEAK_PCI: u32 = 4;
pub const PEAK_USB: u32 = 5;
pub const PEAK_PCC: u32 = 6;
pub const PEAK_VIRTUAL: u32 = 7;
pub const PEAK_LAN: u32 = 8;
pub const PEAK_DEVICE_ID: u32 = 1;
pub const PEAK_5VOLTS_POWER: u32 = 2;
pub const PEAK_RECEIVE_EVENT: u32 = 3;
pub const PEAK_MESSAGE_FILTER: u32 = 4;
pub const PEAK_API_VERSION: u32 = 5;
pub const PEAK_CHANNEL_VERSION: u32 = 6;
pub const PEAK_BUSOFF_AUTORESET: u32 = 7;
pub const PEAK_LISTEN_ONLY: u32 = 8;
pub const PEAK_LOG_LOCATION: u32 = 9;
pub const PEAK_LOG_STATUS: u32 = 10;
pub const PEAK_LOG_CONFIGURE: u32 = 11;
pub const PEAK_LOG_TEXT: u32 = 12;
pub const PEAK_CHANNEL_CONDITION: u32 = 13;
pub const PEAK_HARDWARE_NAME: u32 = 14;
pub const PEAK_RECEIVE_STATUS: u32 = 15;
pub const PEAK_CONTROLLER_NUMBER: u32 = 16;
pub const PEAK_TRACE_LOCATION: u32 = 17;
pub const PEAK_TRACE_STATUS: u32 = 18;
pub const PEAK_TRACE_SIZE: u32 = 19;
pub const PEAK_TRACE_CONFIGURE: u32 = 20;
pub const PEAK_CHANNEL_IDENTIFYING: u32 = 21;
pub const PEAK_CHANNEL_FEATURES: u32 = 22;
pub const PEAK_BITRATE_ADAPTING: u32 = 23;
pub const PEAK_BITRATE_INFO: u32 = 24;
pub const PEAK_BITRATE_INFO_FD: u32 = 25;
pub const PEAK_BUSSPEED_NOMINAL: u32 = 26;
pub const PEAK_BUSSPEED_DATA: u32 = 27;
pub const PEAK_IP_ADDRESS: u32 = 28;
pub const PEAK_LAN_SERVICE_STATUS: u32 = 29;
pub const PEAK_ALLOW_STATUS_FRAMES: u32 = 30;
pub const PEAK_ALLOW_RTR_FRAMES: u32 = 31;
pub const PEAK_ALLOW_ERROR_FRAMES: u32 = 32;
pub const PEAK_INTERFRAME_DELAY: u32 = 33;
pub const PEAK_ACCEPTANCE_FILTER_11BIT: u32 = 34;
pub const PEAK_ACCEPTANCE_FILTER_29BIT: u32 = 35;
pub const PEAK_IO_DIGITAL_CONFIGURATION: u32 = 36;
pub const PEAK_IO_DIGITAL_VALUE: u32 = 37;
pub const PEAK_IO_DIGITAL_SET: u32 = 38;
pub const PEAK_IO_DIGITAL_CLEAR: u32 = 39;
pub const PEAK_IO_ANALOG_VALUE: u32 = 40;
pub const PEAK_FIRMWARE_VERSION: u32 = 41;
pub const PEAK_ATTACHED_CHANNELS_COUNT: u32 = 42;
pub const PEAK_ATTACHED_CHANNELS: u32 = 43;
pub const PEAK_DEVICE_NUMBER: u32 = 1;
pub const PEAK_PARAMETER_OFF: u32 = 0;
pub const PEAK_PARAMETER_ON: u32 = 1;
pub const PEAK_FILTER_CLOSE: u32 = 0;
pub const PEAK_FILTER_OPEN: u32 = 1;
pub const PEAK_FILTER_CUSTOM: u32 = 2;
pub const PEAK_CHANNEL_UNAVAILABLE: u32 = 0;
pub const PEAK_CHANNEL_AVAILABLE: u32 = 1;
pub const PEAK_CHANNEL_OCCUPIED: u32 = 2;
pub const PEAK_CHANNEL_VIEW: u32 = 3;
pub const LOG_FUNCTION_DEFAULT: u32 = 0;
pub const LOG_FUNCTION_ENTRY: u32 = 1;
pub const LOG_FUNCTION_PARAMETERS: u32 = 2;
pub const LOG_FUNCTION_LEAVE: u32 = 4;
pub const LOG_FUNCTION_WRITE: u32 = 8;
pub const LOG_FUNCTION_READ: u32 = 16;
pub const LOG_FUNCTION_ALL: u32 = 65535;
pub const TRACE_FILE_SINGLE: u32 = 0;
pub const TRACE_FILE_SEGMENTED: u32 = 1;
pub const TRACE_FILE_DATE: u32 = 2;
pub const TRACE_FILE_TIME: u32 = 4;
pub const TRACE_FILE_OVERWRITE: u32 = 128;
pub const FEATURE_FD_CAPABLE: u32 = 1;
pub const FEATURE_DELAY_CAPABLE: u32 = 2;
pub const FEATURE_IO_CAPABLE: u32 = 4;
pub const SERVICE_STATUS_STOPPED: u32 = 1;
pub const SERVICE_STATUS_RUNNING: u32 = 4;
pub const MAX_LENGTH_HARDWARE_NAME: u32 = 33;
pub const MAX_LENGTH_VERSION_STRING: u32 = 18;
pub const PEAK_MESSAGE_STANDARD: u32 = 0;
pub const PEAK_MESSAGE_RTR: u32 = 1;
pub const PEAK_MESSAGE_EXTENDED: u32 = 2;
pub const PEAK_MESSAGE_FD: u32 = 4;
pub const PEAK_MESSAGE_BRS: u32 = 8;
pub const PEAK_MESSAGE_ESI: u32 = 16;
pub const PEAK_MESSAGE_ERRFRAME: u32 = 64;
pub const PEAK_MESSAGE_STATUS: u32 = 128;
pub const PEAK_MODE_STANDARD: u32 = 0;
pub const PEAK_MODE_EXTENDED: u32 = 2;
pub const PEAK_BAUD_1M: u32 = 20;
pub const PEAK_BAUD_800K: u32 = 22;
pub const PEAK_BAUD_500K: u32 = 28;
pub const PEAK_BAUD_250K: u32 = 284;
pub const PEAK_BAUD_125K: u32 = 796;
pub const PEAK_BAUD_100K: u32 = 17199;
pub const PEAK_BAUD_95K: u32 = 49998;
pub const PEAK_BAUD_83K: u32 = 34091;
pub const PEAK_BAUD_50K: u32 = 18223;
pub const PEAK_BAUD_47K: u32 = 5140;
pub const PEAK_BAUD_33K: u32 = 35631;
pub const PEAK_BAUD_20K: u32 = 21295;
pub const PEAK_BAUD_10K: u32 = 26415;
pub const PEAK_BAUD_5K: u32 = 32639;
pub const PEAK_TYPE_ISA: u32 = 1;
pub const PEAK_TYPE_ISA_SJA: u32 = 9;
pub const PEAK_TYPE_ISA_PHYTEC: u32 = 4;
pub const PEAK_TYPE_DNG: u32 = 2;
pub const PEAK_TYPE_DNG_EPP: u32 = 3;
pub const PEAK_TYPE_DNG_SJA: u32 = 5;
pub const PEAK_TYPE_DNG_SJA_EPP: u32 = 6;
pub type BYTE = ::std::os::raw::c_uchar;
pub type CHAR = ::std::os::raw::c_char;
pub type WORD = ::std::os::raw::c_ushort;
pub type DWORD = ::std::os::raw::c_ulong;
pub type UINT64 = ::std::os::raw::c_ulonglong;
pub type LPSTR = *mut CHAR;
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCANTPMsg {
    pub ID: DWORD,
    pub MSGTYPE: BYTE,
    pub LEN: BYTE,
    pub DATA: [BYTE; 8usize],
}

#[doc = ""]
pub type CANTPMsg = tagCANTPMsg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCANTPTimestamp {
    pub millis: DWORD,
    pub millis_overflow: WORD,
    pub micros: WORD,
}

pub type CANTPTimestamp = tagCANTPTimestamp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCANTPMsgFD {
    pub ID: DWORD,
    pub MSGTYPE: BYTE,
    pub DLC: BYTE,
    pub DATA: [BYTE; 64usize],
}

pub type CANTPMsgFD = tagCANTPMsgFD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCANTPChannelInformation {
    pub channel_handle: WORD,
    pub device_type: BYTE,
    pub controller_number: BYTE,
    pub device_features: DWORD,
    pub device_name: [::std::os::raw::c_char; 33usize],
    pub device_id: DWORD,
    pub channel_condition: DWORD,
}

pub type CANTPChannelInformation = tagCANTPChannelInformation;
unsafe extern "C" {
    #[doc = " <summary>"]
    #[doc = " Initializes a CAN Channel"]
    #[doc = " </summary>"]
    #[doc = " <param name=\"Channel\">\"The handle of a CAN Channel\"</param>"]
    #[doc = " <param name=\"Btr0Btr1\">\"The speed for the communication (BTR0BTR1 code)\"</param>"]
    #[doc = " <param name=\"HwType\">\"Non-PnP: The type of hardware and operation mode\"</param>"]
    #[doc = " <param name=\"IOPort\">\"Non-PnP: The I/O address for the parallel port\"</param>"]
    #[doc = " <param name=\"Interrupt\">\"Non-PnP: Interrupt number of the parallel port\"</param>"]
    #[doc = " <returns>\"A CANTPStatus error code\"</returns>"]
    pub fn CAN_Initialize(
        Channel: WORD,
        Btr0Btr1: WORD,
        HwType: BYTE,
        IOPort: DWORD,
        Interrupt: WORD,
    ) -> DWORD;
}
unsafe extern "C" {
    #[doc = " <example>f_clock=80000000,nom_brp=10,nom_tseg1=5,nom_tseg2=2,nom_sjw=1,data_brp=4,data_tseg1=7,data_tseg2=2,data_sjw=1</example>"]
    #[doc = " <returns>\"A CANTPStatus error code\"</returns>"]
    pub fn CAN_InitializeFD(Channel: WORD, BitrateFD: LPSTR) -> DWORD;
}
unsafe extern "C" {
    #[doc = " <summary>"]
    #[doc = " Uninitializes one or all CAN Channels initialized by CAN_Initialize"]
    #[doc = " </summary>"]
    #[doc = " <remarks>Giving the CANTPHandle value \"PEAK_NONEBUS\","]
    #[doc = " uninitialize all initialized channels</remarks>"]
    #[doc = " <param name=\"Channel\">\"The handle of a CAN Channel\"</param>"]
    #[doc = " <returns>\"A CANTPStatus error code\"</returns>"]
    pub fn CAN_Uninitialize(Channel: WORD) -> DWORD;
}
unsafe extern "C" {
    #[doc = " <summary>"]
    #[doc = " Resets the receive and transmit queues of the CAN Channel"]
    #[doc = " </summary>"]
    #[doc = " <remarks>"]
    #[doc = " A reset of the CAN controller is not performed."]
    #[doc = " </remarks>"]
    #[doc = " <param name=\"Channel\">\"The handle of a CAN Channel\"</param>"]
    #[doc = " <returns>\"A CANTPStatus error code\"</returns>"]
    pub fn CAN_Reset(Channel: WORD) -> DWORD;
}
unsafe extern "C" {
    #[doc = " <summary>"]
    #[doc = " Gets the current status of a CAN Channel"]
    #[doc = " </summary>"]
    #[doc = " <param name=\"Channel\">\"The handle of a CAN Channel\"</param>"]
    #[doc = " <returns>\"A CANTPStatus error code\"</returns>"]
    pub fn CAN_GetStatus(Channel: WORD) -> DWORD;
}
unsafe extern "C" {
    #[doc = " <summary>"]
    #[doc = " Reads a CAN message from the receive queue of a CAN Channel"]
    #[doc = " </summary>"]
    #[doc = " <param name=\"Channel\">\"The handle of a CAN Channel\"</param>"]
    #[doc = " <param name=\"MessageBuffer\">\"A CANTPMsg structure buffer to store the CAN message\"</param>"]
    #[doc = " <param name=\"TimestampBuffer\">\"A CANTPTimestamp structure buffer to get"]
    #[doc = " the reception time of the message. If this value is not desired, this parameter"]
    #[doc = " should be passed as NULL\"</param>"]
    #[doc = " <returns>\"A CANTPStatus error code\"</returns>"]
    pub fn CAN_Read(
        Channel: WORD,
        MessageBuffer: *mut CANTPMsg,
        TimestampBuffer: *mut CANTPTimestamp,
    ) -> DWORD;
}
unsafe extern "C" {
    #[doc = " <summary>"]
    #[doc = " Reads a CAN message from the receive queue of a FD capable CAN Channel"]
    #[doc = " </summary>"]
    #[doc = " <param name=\"Channel\">\"The handle of a FD capable CAN Channel\"</param>"]
    #[doc = " <param name=\"MessageBuffer\">\"A CANTPMsgFD structure buffer to store the CAN message\"</param>"]
    #[doc = " <param name=\"TimestampBuffer\">\"A CANTPTimestampFD buffer to get"]
    #[doc = " the reception time of the message. If this value is not desired, this parameter"]
    #[doc = " should be passed as NULL\"</param>"]
    #[doc = " <returns>\"A CANTPStatus error code\"</returns>"]
    pub fn CAN_ReadFD(
        Channel: WORD,
        MessageBuffer: *mut CANTPMsgFD,
        TimestampBuffer: *mut UINT64,
    ) -> DWORD;
}
unsafe extern "C" {
    #[doc = " <summary>"]
    #[doc = " Transmits a CAN message"]
    #[doc = " </summary>"]
    #[doc = " <param name=\"Channel\">\"The handle of a CAN Channel\"</param>"]
    #[doc = " <param name=\"MessageBuffer\">\"A CANTPMsg buffer with the message to be sent\"</param>"]
    #[doc = " <returns>\"A CANTPStatus error code\"</returns>"]
    pub fn CAN_Write(Channel: WORD, MessageBuffer: *mut CANTPMsg) -> DWORD;
}
unsafe extern "C" {
    #[doc = " <summary>"]
    #[doc = " Transmits a CAN message over a FD capable CAN Channel"]
    #[doc = " </summary>"]
    #[doc = " <param name=\"Channel\">\"The handle of a FD capable CAN Channel\"</param>"]
    #[doc = " <param name=\"MessageBuffer\">\"A CANTPMsgFD buffer with the message to be sent\"</param>"]
    #[doc = " <returns>\"A CANTPStatus error code\"</returns>"]
    pub fn CAN_WriteFD(Channel: WORD, MessageBuffer: *mut CANTPMsgFD) -> DWORD;
}
unsafe extern "C" {
    #[doc = " <summary>"]
    #[doc = " Configures the reception filter."]
    #[doc = " </summary>"]
    #[doc = " <remarks>The message filter will be expanded with every call to"]
    #[doc = " this function. If it is desired to reset the filter, please use"]
    #[doc = " the CAN_SetValue function</remarks>"]
    #[doc = " <param name=\"Channel\">\"The handle of a CAN Channel\"</param>"]
    #[doc = " <param name=\"FromID\">\"The lowest CAN ID to be received\"</param>"]
    #[doc = " <param name=\"ToID\">\"The highest CAN ID to be received\"</param>"]
    #[doc = " <param name=\"Mode\">\"Message type, Standard (11-bit identifier) or"]
    #[doc = " Extended (29-bit identifier)\"</param>"]
    #[doc = " <returns>\"A CANTPStatus error code\"</returns>"]
    pub fn CAN_FilterMessages(Channel: WORD, FromID: DWORD, ToID: DWORD, Mode: BYTE) -> DWORD;
}
unsafe extern "C" {
    #[doc = " <summary>"]
    #[doc = " Retrieves a CAN Channel value"]
    #[doc = " </summary>"]
    #[doc = " <remarks>Parameters can be present or not according with the kind"]
    #[doc = " of Hardware (CAN Channel) being used. If a parameter is not available,"]
    #[doc = " a PEAK_ERROR_ILLPARAMTYPE error will be returned</remarks>"]
    #[doc = " <param name=\"Channel\">\"The handle of a CAN Channel\"</param>"]
    #[doc = " <param name=\"Parameter\">\"The CANTPParameter parameter to get\"</param>"]
    #[doc = " <param name=\"Buffer\">\"Buffer for the parameter value\"</param>"]
    #[doc = " <param name=\"BufferLength\">\"Size in bytes of the buffer\"</param>"]
    #[doc = " <returns>\"A CANTPStatus error code\"</returns>"]
    pub fn CAN_GetValue(
        Channel: WORD,
        Parameter: BYTE,
        Buffer: *mut ::std::os::raw::c_void,
        BufferLength: DWORD,
    ) -> DWORD;
}
unsafe extern "C" {
    #[doc = " <summary>"]
    #[doc = " Configures or sets a CAN Channel value"]
    #[doc = " </summary>"]
    #[doc = " <remarks>Parameters can be present or not according with the kind"]
    #[doc = " of Hardware (CAN Channel) being used. If a parameter is not available,"]
    #[doc = " a PEAK_ERROR_ILLPARAMTYPE error will be returned</remarks>"]
    #[doc = " <param name=\"Channel\">\"The handle of a CAN Channel\"</param>"]
    #[doc = " <param name=\"Parameter\">\"The CANTPParameter parameter to set\"</param>"]
    #[doc = " <param name=\"Buffer\">\"Buffer with the value to be set\"</param>"]
    #[doc = " <param name=\"BufferLength\">\"Size in bytes of the buffer\"</param>"]
    #[doc = " <returns>\"A CANTPStatus error code\"</returns>"]
    pub fn CAN_SetValue(
        Channel: WORD,
        Parameter: BYTE,
        Buffer: *mut ::std::os::raw::c_void,
        BufferLength: DWORD,
    ) -> DWORD;
}
unsafe extern "C" {
    #[doc = " <summary>"]
    #[doc = " Returns a descriptive text of a given CANTPStatus error"]
    #[doc = " code, in any desired language"]
    #[doc = " </summary>"]
    #[doc = " <remarks>The current languages available for translation are:"]
    #[doc = " Neutral (0x00), German (0x07), English (0x09), Spanish (0x0A),"]
    #[doc = " Italian (0x10) and French (0x0C)</remarks>"]
    #[doc = " <param name=\"Error\">\"A CANTPStatus error code\"</param>"]
    #[doc = " <param name=\"Language\">\"Indicates a 'Primary language ID'\"</param>"]
    #[doc = " <param name=\"Buffer\">\"Buffer for a null terminated char array\"</param>"]
    #[doc = " <returns>\"A CANTPStatus error code\"</returns>"]
    pub fn CAN_GetErrorText(Error: DWORD, Language: WORD, Buffer: LPSTR) -> DWORD;
}
